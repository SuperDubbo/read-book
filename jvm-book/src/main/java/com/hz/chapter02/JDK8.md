# JDK8相关介绍

Java8运行时数据区域（Run-Time Data Areas）
1. 程序计数器（The pc Register）  
Java虚拟机可以同时支持多个执行线程（JLS§17）。每个Java虚拟机线程都有自己的 pc（程序计数器）寄存器。在任何时候，每个Java虚拟机线程都在执行单个方法的代码，即该线程的当前方法（§2.6）。如果该方法不是 native，则该pc寄存器包含当前正在执行的Java虚拟机指令的地址。如果线程当前正在执行的方法是native，那么Java虚拟机pc 寄存器的值是未定义的。Java虚拟机的pc寄存器足够宽以returnAddress在特定平台上保存一个或一个本机指针
2. Java虚拟机栈（Java Virtual Machine Stacks）  
每个Java虚拟机线程都有一个私有Java虚拟机堆栈，与该线程同时创建。Java虚拟机堆栈存储帧（第2.6节）。Java虚拟机堆栈类似于传统语言（如C语言）的堆栈：它包含局部变量和部分结果，并在方法调用和返回中扮演角色。由于除了推送和弹出框架之外，Java虚拟机堆栈从不直接操作，所以可能会分配堆栈。Java虚拟机堆栈的内存不需要是连续的。  
在第一版中的Java ®虚拟机规范，Java虚拟机堆被称为Java堆栈。  
该规范允许Java虚拟机堆栈具有固定的大小，或者根据计算的需要动态扩展和收缩。如果Java虚拟机堆栈的大小是固定的，则每个Java虚拟机堆栈的大小可以在创建堆栈时独立选择。  
Java虚拟机实现可以为程序员或用户提供对Java虚拟机堆栈初始大小的控制，并且在动态扩展或收缩Java虚拟机堆栈的情况下，可以控制最大和最小大小。  
以下特殊情况与Java虚拟机堆栈相关联：  
`如果线程中的计算需要比允许的更大的Java虚拟机堆栈，那么Java虚拟机将抛出a StackOverflowError。`  
`如果Java虚拟机堆栈可以动态扩展，并且尝试扩展，但是没有足够的内存可用于扩展，或者如果没有足够的内存可用于为新线程创建初始Java虚拟机堆栈，则Java虚拟机机器抛出一个OutOfMemoryError。`    
3. 堆（Heap）
Java虚拟机具有在所有Java虚拟机线程中共享的堆。堆是所有类实例和数组的内存分配的运行时数据区。  
该堆是在虚拟机启动时创建的。对象的堆存储由自动存储管理系统（称为垃圾收集器）回收 ; 对象从不显式释放。Java虚拟机假定没有特定类型的自动存储管理系统，并且存储管理技术可以根据实现者的系统要求来选择。堆可以是固定大小的，或者可以根据计算的需要进行扩展，并且如果不需要更大的堆，则堆可以被缩小。堆的内存不需要是连续的。  
Java虚拟机实现可以提供程序员或用户控制堆的初始大小，以及如果堆可以动态扩展或收缩，则控制最大和最小堆大小。  
以下异常情况与堆相关联：  
`如果计算需要比自动存储管理系统更多的堆，Java虚拟机会抛出一个 OutOfMemoryError。`
4. 方法区（Method Area）
Java虚拟机具有在所有Java虚拟机线程中共享的方法区域。方法区域类似于常规语言的编译代码的存储区域或类似于操作系统进程中的“文本”段。它存储每类结构，如运行时常量池，字段和方法数据，以及方法和构造函数的代码，包括用于类和实例初始化和接口初始化的特殊方法（第2.9节）。  
方法区域是在虚拟机启动时创建的。虽然方法区域在逻辑上是堆的一部分，但是简单的实现可以选择不垃圾收集或压缩它。本规范不要求方法区域的位置或用于管理编译代码的策略。方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展，并且如果更大的方法区域变得不必要，则可以缩小方法区域。方法区域的内存不需要是连续的。  
Java虚拟机实现可以提供程序员或用户对方法区域的初始大小的控制，以及在变大小方法区域的情况下控制最大和最小方法区域大小。  
以下异常情况与方法区域相关联：  
`如果方法区域中的内存无法满足分配请求，则Java虚拟机会抛出一个OutOfMemoryError。`
5. 运行时常量池（Run-Time Constant Pool）  
甲运行时间常数池是的每个类或每个接口的运行时表示constant_pool在表class文件（§4.4）。它包含几种常量，从编译时已知的数字文字到必须在运行时解析的方法和字段引用。运行时常量池提供的功能类似于传统编程语言符号表的功能，尽管它包含比典型符号表更广泛的数据范围。  
每个运行时常量池都是从Java虚拟机的方法区域（§2.5.4）分配的。类或接口的运行时常量池是在Java虚拟机创建类或接口（§5.3）时构建的。  
以下异常情况与类或接口的运行时常量池的构造相关联：  
`在创建类或接口时，如果运行时常量池的构造需要比Java虚拟机的方法区域更多的内存，Java虚拟机将抛出一个OutOfMemoryError。`
6. 本地方法栈（Native Method Stacks）  
Java虚拟机的实现可以使用俗称“C堆栈”的常规堆栈来支持native方法（用Java编程语言以外的语言编写的方法）。原生方法堆栈也可以通过Java虚拟机的指令集的解释器实现，如C语言。无法加载native 方法的Java虚拟机实现并且本身不依赖于传统堆栈的实现不需要提供本地方法堆栈。如果提供，则在创建每个线程时，通常为每个线程分配本地方法堆栈。  
该规范允许本地方法栈或者具有固定大小，或者根据计算的需要动态扩展和收缩。如果本地方法堆栈的大小是固定的，则每个本地方法堆栈的大小可以在创建堆栈时独立选择。  
Java虚拟机实现可以提供程序员或用户控制本地方法堆栈的初始大小，以及在大小不一的本地方法堆栈的情况下控制最大和最小方法堆栈大小。  
以下异常情况与本地方法堆栈相关联：  
`如果线程中的计算需要比允许的更大的本地方法堆栈，那么Java虚拟机会抛出一个StackOverflowError。`  
`如果可以动态扩展本机方法堆栈并尝试本机方法堆栈扩展，但是没有足够的内存可用，或者如果没有足够的内存可用于为新线程创建初始本机方法堆栈，Java虚拟机将抛出一个OutOfMemoryError。`

# 参考文档：
[Oracle官方文档](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5)  
[博客](https://blog.csdn.net/tophawk/article/details/78704074QW)  
[博客](https://blog.csdn.net/hylexus/article/details/53771460)